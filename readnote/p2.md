# 2 线程管理

## 线程管理基础
## 2.1.1 启动线程

#### 参数

- 参数是无参数无返回的函数
- 仿函数 不能传递临时变量，否则会被解析成函数声明 （可以使用多组括号或者新统一的初始化语法花括号避免这个问题）
- lambda表达式 

#### 行为

> 需要在线程执行完之前调用，否则程序会终止

- joined 
- detached 

#### 变量生命周期
- 访问一个已经销毁的变量会产生错误
- 通常将一个数据复制到数据，而非复制到共享变量；使用一个能访问局部变量的函数创造线程不是个好主意


### 2.1.2 等待线程完成
- join()
  - 简单控制：等待完成或者不等待
  - 清理线程相关的存储部分
  - 使用前需要使用my_thread.joinable()进行确认

### 2.1.3 特殊情况下的等待
- 抛出异常时，优先处理异常，当一场在join()调用前抛出，join()会被跳过
- 避免join()被异常跳过，在异常处理过程中调用join()可以避免
- 使用RAII(资源获取即初始化)技术，新建一个对象，该析构函数对线程调用join()操作
  - 即使发生异常，对象的析构函数总会发生，从而使对线程调用join()总会发生

### 2.1.4 后台线程运行
- detach()使线程在后台运行
  - 线程分离后(detach)后，不能有std::thread对象引用它，
  - c++保证在分离的线程退出后，相关的资源能够被回收
  - 分离线程也被称为守护线程(daemon threads),长时间运行，监视文件系统，清理缓存等功能，(fire and forget)
  - 使用前需要使用my_thread.joinable()进行确认，同`joinable()`



## 2.2 向线程传递参数
- 构造函数传递简单参数
  - 传递字符串数组时，可能由于复制时只复制了字面的字符串而出问题，转换成string后传递可以解决这个问题
  - 函数的参数是一个引用时，直接传参会编译出错，原因是参数拷贝是以右值的方式，可以用std::ref()来解决，见std::bind()
  - std::thread 创建以对象的成员函数的线程。注意提供的参数只能移动，不能复制，数据移动后不在原始对象中进行保存,成为一个临时变量。
  - 使用std::unique_ptr与std::move()将变量移动到线程中
  - 执行线程的所有权可以在多个std::thread实例中相互转移，std::thread的可移动但不可复制性



## faq
- std::bind std::ref
- 测试线程中运行对象的成员函数
- 使用std::unique_ptr与std::move()将变量移动到线程中
- 

