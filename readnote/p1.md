# P1 

## 1.1 并发的含义

- 多个独立活动同时发生



### 1.1.1 计算机中的并发

- 单处理器：用任务切换实现并发 
  - 任务切换时需要切换上下文
- 单芯多核：硬件并发
  - 各自进行

- 如何使用并发很大程度上却决于硬件并发，但是技术通用



### 1.1.2 并发的途径

- 多进程 

  - 不是设置复杂就是速度慢，操作系统间的保护措施
  - 多个进行的固定开销大：启动，管理
  - 更安全
  - 可使用远程连接，在不同的电脑上运行独立的进程 提高并行可用性和性能

- 多线程

  - 每个线程独立运行
  - 共享地址空间，都能访问到大部分数据全局变量，数据在线程间传递
  - 开销较小
  - 线程间数据共享可能遇到问题，数据一致性

### 1.1.3 并行与并发

- 并行更注重性能

- #### 并发更关注任务的分离

  

  

## 1.2 为什么使用并发

### 1.2.1 关注点分离
- 操作可以同时发生
- 线程数量不受限于CPU核心数量
  

### 1.2.2  性能
- 任务并行(task parallelism) 将单个任务分离成多个分别执行
- 数据并行(data parallelism) 在不同的数据部分分别执行相同的操作

- 易并行算法（embarrassingly parallel） 良好的拓展性，将算法分割成若干部分
- 可并行算法   使用更多线程进行处理，同时处理更多任务

### 1.2.3 什么时候不用并发
- 成本与收益
- 线程管理的耗费的时间大于并行处理任务带来的收益
- 硬件限制

## 1.3 C++的并发与多线程

### 1.3.1 历史
- C++98不承认
- 使用c语言或者平台相关的库

### 1.3.2 c++11
- 管理线程
- 保护共享数据
- 线程操作同步
- 低层原子操作
由boost演变

### 1.3.3 c++14 c++17 
- c++14:新增互斥量模型，用于保护共享数据
- c++17:
  - 添加一整套并行算法
  - 补充标准库
  - 支持原子操作



### 1.3.4 c++线程库的效率

- 高级工具（效率并不低）与底层工具（足够多）



### 1.3.5 平台相关工具

- `native_handle()`



## 1.4 入门



## 1.5 总结

